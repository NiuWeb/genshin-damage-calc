import { GetSubstatValue } from "@core/scaling"
import { CountRollsBruteForce } from "./count_brute"
import { CountRollsLp } from "./count_lp"
import { Options, Result } from "./type"

/**
 * Finds the minimum rolls count for the given substats.
 * 
 * The function first will try to solve by using
 * a linear programming approach, and if it fails 
 * (due to the input substats being unrealistic)
 * then will solve it using brute force.
 * 
 * @param options The solver options.
 * @param mode The solver to use ("lp", "brute" or "auto"). Default is "auto"
 * @returns An array in the form `[tier 0, tier 1, tier 2, tier 3]`
 */
export function CountRolls(options: Options, mode: "auto" | "lp" | "brute" = "auto"): Result {
    switch (mode) {
        case "auto":
            try {
                return CountRollsLp(options)
            } catch (e) {
                return CountRollsBruteForce(options)
            }
        case "lp":
            return CountRollsLp(options)
        case "brute":
            return CountRollsBruteForce(options)
    }
}

/**
 * Transforms the object generated by `SolveRolls(...)` by changing
 * the array of tiers (`[# rolls tier 0, # rolls tier 1, ...]`) to an array
 * of roll values (`[value 0, value 1, ...]`)
 * @param stars Artifact stars
 * @param input result generated by solvers
 */
export function FormatRolls(stars: number, input: Result): Result {
    const result: Result = []

    for (const [stat, rolls] of input) {
        const values: number[] = []
        for (let i = 0; i < 4; i++) {
            const roll = GetSubstatValue(stars, stat, i)
            for (let j = 0; j < rolls[i]; j++) {
                values.push(roll)
            }
        }
        result.push([stat, values])
    }

    return result
}